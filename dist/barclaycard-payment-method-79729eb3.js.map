{"version":3,"file":"barclaycard-payment-method-79729eb3.js","mappings":"4NAiGA,MAmHA,EAnH6EA,IACzE,MAAM,YACFC,EAAW,eACXC,GAAiB,EAAK,kBACtBC,EAAiB,OACjBC,EAAM,iBACNC,EAAmB,EAAAC,KAAI,oBACvBC,GACAP,GAEGQ,EAAuBC,IAA4B,IAAAC,WAAS,IAC5DC,EAAoBC,IAAyB,IAAAF,YAE9CG,EAhEV,SACIb,GAEA,MAAMc,GAA2B,SAAW,CAACC,EAAmC,KAC5EA,EAAYC,OAAO,OAEjBC,GAA2B,SAAW,CAACF,EAAmC,KAC5EA,EAAYC,QAAO,EAAGE,4BAA6BA,OAEjD,gBAAEC,EAAe,cAAEC,EAAa,qBAAEC,GAAuB,EAAK,OAAEjB,GAAWJ,GAG7EsB,MAAM,QACFC,EAAO,UACPC,EAAS,YACTC,EAAW,eACXC,EAAc,sBACdC,EAAqB,uBACrBC,GAEJC,UAAU,qBAAEC,IACZV,EAEEW,EAAOR,IACPS,EAASR,IACTS,EAAWR,IAEjB,IAAKO,IAAWD,IAASE,EACrB,MAAM,IAAIC,MAAM,0BAGpB,MAAMC,EAA2BrB,EAAyBY,EAAetB,IACnEgC,EAAqBnB,EAAyBkB,GAEpD,MAAO,CACHpB,YAAaqB,EACbC,aAA4C,IAA9BD,EAAmBE,QAAgBH,EAAyBG,OAAS,EACnFC,8BACKX,EAAuBxB,EAAOoC,GAAIpC,EAAOqC,WAC1C,OAA6B,CACzBT,SACAC,WACAZ,uBACAqB,cAAetC,IAEvB0B,qBAAsBA,IACtBH,sBAAuBA,IACvBgB,gBAAiBxB,EAAgBwB,gBAEzC,CAeyBC,CAAmC5C,IAClD,qBACF8B,EAAoB,YACpBf,EAAW,aACXsB,EACAE,6BAA8BM,EAAgC,gBAC9DF,GACA9B,EAEEiC,GAAuB,IAAAC,cAAY,KACrC,IAAIvC,GAA0BO,EAAYuB,OAI1C,OAAO,IAAAU,MAAKjC,EAAa,CAAEkC,mBAAmB,KAAWlC,EAAY,KACtE,CAACP,EAAuBO,IAErBmC,GAAyB,IAAAH,cAAY,KACvCtC,GAAyB,GACzBG,OAAsBuC,KACvB,IAEGC,GAAyB,IAAAL,cAC1BP,IACG/B,GAAyB,GACzBG,GAAsB,IAAAoC,MAAKjC,EAAa,CAAEsC,YAAab,OAE3D,CAACzB,KAGL,IAAAuC,YAAU,MACqC,iDACvC,UACUnD,EAAkB,CACpBoD,UAAWnD,EAAOqC,QAClBe,SAAUpD,EAAOoC,KAGjBK,UACMF,IAEd,CAAE,MAAOc,GACLpD,EAAiBoD,EACrB,CACJ,IAIO,MAC0C,iDACzC,UACUlD,EAAoB,CACtBgD,UAAWnD,EAAOqC,QAClBe,SAAUpD,EAAOoC,IAEzB,CAAE,MAAOiB,GACLpD,EAAiBoD,EACrB,CACJ,OAKL,IAEH,MAAMC,EAA4B/C,GAAsBmC,IAClDa,EAAYzD,GAAkB4B,EAC9B8B,EACFf,IAAqC9B,EAAYuB,OAAS,GAAKD,GAEnE,OAAKpC,GAAgB4C,EAKjB,gBAAC,IAAc,CAACgB,wBAAsB,EAACF,UAAWA,GAC9C,uBAAKG,UAAU,uCACV7D,EAEA2D,GACG,gBAAC,EAAAG,EAAyB,CACtBhD,YAAaA,EACbiD,mBAAoBZ,EACpBa,mBAAoBf,EACpBvC,mBAAoB+C,IAI3Bb,GACG,gBAAC,IAAuB,CACpBqB,aACIR,GAA6BA,EAA0BL,YAE3DtC,YAAaA,EACboD,qBAAqB,MAvB9B,K,0GC1Kf,MA8BA,GAAe,E,SAAA,IA9B0D,I,IAAA,gBACrEhD,EAAe,cACfC,EAAa,OACbhB,EAAM,YACNgE,GAAW,EACRC,GAAI,cAL8D,4DAOrE,MAAMC,GAA+B,IAAAvB,cAChCwB,GACUpD,EAAgBhB,kBAAkB,OAAD,wBACjCoE,GAAO,CACVC,aAAc,CAAC,SAGvB,CAACrD,IAGL,OACI,gBAACsD,EAAA,EAAsB,iBACfJ,EAAI,CACRlD,gBAAiBA,EACjBC,cAAeA,EACfb,oBAAqBY,EAAgBZ,oBACrCJ,kBAAmBmE,EACnBlE,OAAQA,EACRgE,YAAaA,OAOrB,CAAC,CAAE3B,QAAS,gB,uCCzCJiC,EAAAA,E,WCKG,MAAeC,UAAsBzC,MAIhD,WAAA0C,CAAYC,GCXD,IAAqCC,EDY5CC,MAAMF,GAAW,qCAJrB,KAAAG,KAAO,gBACP,KAAAC,KAAO,WCTyCH,aDcZA,UCbhCI,OAAOC,eACPD,OAAOC,eDYQC,KCZeN,GDYfM,KCVRC,UAAYP,EDYoB,mBAA5B5C,MAAMoD,kBACbpD,MAAMoD,kBAAkBF,iBAExBA,KAAKG,MAAQ,IAAIrD,MAAMkD,KAAKP,SAASU,KAE7C,EEdW,MAAMC,UAA6Bb,EAC9C,WAAAC,CAAYC,GACRE,MAAMF,GAAW,yCAEjBO,KAAKJ,KAAO,uBACZI,KAAKH,KAAO,kBAChB,ECPW,MAAMQ,UAA0Cd,EAC3D,WAAAC,GACIG,MAAM,kEAENK,KAAKJ,KAAO,oCACZI,KAAKH,KAAO,iCAChB,ECLW,MAAMS,UAAoCF,EACrD,WAAAZ,CAAYe,GACR,IAAId,EAAU,yEAEVc,IACAd,EAAU,GAAGA,4DAAkEc,EAAcC,KACzF,UAIRb,MAAMF,GAENO,KAAKJ,KAAO,6BAChB,GLlBQN,EAAAA,IAAAA,EAAuB,KAC/B,EAAAmB,6BAAA,kCACA,IAAAC,uBAAA,4BACA,IAAAC,sBAAA,2BACA,IAAAC,uBAAA,4BACA,IAAAC,6BAAA,kCAQW,MAAMC,UAA4BvB,EAC7C,WAAAC,CAAmBuB,GACfpB,MAOR,SAAyBE,GACrB,OAAQA,GACJ,KAAKP,EAAwBoB,uBACzB,MAAO,oFAEX,KAAKpB,EAAwBqB,sBACzB,MAAO,mFAEX,KAAKrB,EAAwBsB,uBACzB,MAAO,oFAEX,KAAKtB,EAAwBuB,6BACzB,MAAO,mFAEX,QACI,MAAO,6EAEnB,CAjBA,CAP8BE,IADP,KAAAA,QAAAA,EAGff,KAAKJ,KAAO,sBACZI,KAAKH,KAAO,iBAChB,E,snBMHW,MAAMmB,EAIjB,WAAAxB,CAAsByB,GAAA,KAAAA,2BAAAA,CAAwD,CAE9E,OAAAC,CAAQC,EAA2BhC,G,QAC/B,OAAOa,KAAKoB,4BACO,QAAf,EAAAD,EAAQE,eAAAA,IAAO,WAAEjD,SACF,QAAf,EAAA+C,EAAQE,eAAAA,IAAO,WAAElD,YAChB6B,KAAKsB,wBACJtB,KAAKuB,uBAAuBJ,EAAShC,GACrCa,KAAKwB,0BAA0BL,EAAShC,EAClD,CAEA,UAAAsC,CACItC,GAEA,IACKa,KAAKoB,4BAA4BjC,MAAAA,OAAAA,EAAAA,EAASf,SAAUe,MAAAA,OAAAA,EAAAA,EAAShB,aAC7D6B,KAAK0B,wBAAwBvC,GAI9B,OAFAa,KAAKsB,yBAAAA,EAEEK,QAAQC,UAGnB,MAAMC,EAAc1C,GAAWA,EAAQ2C,YAAc3C,EAAQ2C,WAAWC,KAClEC,EAAQhC,KAAKiB,2BAA2BgB,YACtCC,iBAAmBC,cAAeC,EAAO,IAAO,CAAC,GACrDJ,EAAMK,wBAEV,IAAKR,EACD,MAAM,IAAIzB,EAGd,MAAM2B,EAAO/B,KAAKiB,2BAA2BqB,iBAAiBF,EAAMP,GAEpE,OAAOE,EAAKQ,SAASC,MAAK,KACtBxC,KAAKsB,yBAAAA,EACLtB,KAAKyC,YAAcV,EAEZJ,QAAQC,YAEvB,CAEA,YAAAc,GAKI,OAJI1C,KAAKyC,aACLzC,KAAKyC,YAAYE,SAGdhB,QAAQC,SACnB,CAEA,QAAAgB,GACI,OAAOjB,QAAQkB,OAAO,IAAIxC,EAC9B,CAEgB,yBAAAmB,CACZL,EACAhC,G,yCAEA,MAAM,QAAEkC,GAAsBF,EAAV2B,EAAK,EAAK3B,EAAxB,aACA4B,EAAc1B,GAAWA,EAAQ0B,YAEvC,IAAK1B,IAAY0B,EACb,MAAM,IAAIzC,EAA4B,CAAC,8BAGrCN,KAAKiB,2BAA2B+B,YAAYF,EAAO3D,SAEnDa,KAAKiB,2BAA2BgC,cAAc,OAAD,wBAAM5B,GAAO,CAAE0B,YAAAA,IACtE,G,CAEgB,sBAAAxB,CACZJ,EACAhC,G,yCAEA,MAAM,QAAEkC,GAAsBF,EAAV2B,EAAK,EAAK3B,EAAxB,aACAY,EAAO/B,KAAKyC,YAElB,IAAKV,EACD,MAAM,IAAIjB,EAAoBxB,EAAwBqB,uBAG1D,IAAKU,IAAYA,EAAQjD,SACrB,MAAM,IAAIkC,EAA4B,CAAC,2BAGrCN,KAAKiB,2BAA2B+B,YAAYF,EAAO3D,SAEnD4C,EAAKmB,WAAWV,MAAK,IAAMT,EAAKoB,OAAO9B,IACjD,G,CAEU,2BAAAD,CAA4BhD,EAAmBD,GACrD,QAAKC,IAAAA,IAIS4B,KAAKiB,2BAA2BgB,WAClBmB,wBAAwBhF,EAAUD,GAEzCvB,OAAOyG,mBAChC,CAEQ,uBAAA3B,CACJvC,GAEA,QAAQmE,EAAAA,EAAAA,QAAOnE,GAAWA,EAAQ2C,YAAc3C,EAAQ2C,WAAWC,KAAKwB,QAAQC,MAC5EC,EAAAA,MAER,EC1HJ,MAMA,GCVIC,EDKAC,GAEO,IAAI3C,EAA0B2C,GCNrCC,EDS+D,CAAC,CAAEC,SAAQ,ICPnE/D,OAAOgE,OAAOJ,EAAQ,CAAEE,WAAAA,KAJpB,IACXF,EACAE,C,kBCKW,SAASzG,GAA6B,OACjDP,EAAM,SACNC,EAAQ,qBACRZ,EAAoB,cACpBqB,IAEA,SACKV,EAAOmH,iBAAiBC,wBACxB1G,EAAcV,OAAOqH,mBACtBpH,EAASqH,SACTjI,EAMR,C","sources":["webpack://checkout/./packages/hosted-payment-integration/src/components/HostedPaymentComponent.tsx","webpack://checkout/./packages/barclay-integration/src/BarclaycardPaymentMethod.tsx","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/not-initialized-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/standard-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/set-prototype-of.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/invalid-argument-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/order-finalization-not-required-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-argument-invalid-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/credit-card-integration/src/credit-card-payment-strategy.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/credit-card-integration/src/create-credit-card-payment-strategy.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/to-resolvable-module.ts","webpack://checkout/./packages/instrument-utils/src/guards/isInstrumentFeatureAvailable/isInstrumentFeatureAvailable.ts"],"sourcesContent":["import {\n    type AccountInstrument,\n    type CheckoutSelectors,\n    type CheckoutService,\n    type LanguageService,\n    type PaymentInitializeOptions,\n    type PaymentInstrument,\n    type PaymentMethod,\n    type PaymentRequestOptions,\n} from '@bigcommerce/checkout-sdk';\nimport { memoizeOne } from '@bigcommerce/memoize';\nimport { find, noop } from 'lodash';\nimport React, { type ReactNode, useCallback, useEffect, useState } from 'react';\n\nimport {\n    AccountInstrumentFieldset,\n    isAccountInstrument,\n    isInstrumentFeatureAvailable,\n    StoreInstrumentFieldset,\n} from '@bigcommerce/checkout/instrument-utils';\nimport { type PaymentFormService } from '@bigcommerce/checkout/payment-integration-api';\nimport { LoadingOverlay } from '@bigcommerce/checkout/ui';\n\nexport interface HostedPaymentComponentProps {\n    checkoutService: CheckoutService;\n    checkoutState: CheckoutSelectors;\n    description?: ReactNode;\n    isInitializing?: boolean;\n    isUsingMultiShipping?: boolean;\n    language: LanguageService;\n    method: PaymentMethod;\n    paymentForm: PaymentFormService;\n    deinitializePayment(options: PaymentRequestOptions): Promise<CheckoutSelectors>;\n    initializePayment(options: PaymentInitializeOptions): Promise<CheckoutSelectors>;\n    onUnhandledError?(error: Error): void;\n}\n\ninterface HostedPaymentComponentDerivedProps {\n    instruments: AccountInstrument[];\n    isInstrumentFeatureAvailable: boolean;\n    isLoadingInstruments: boolean;\n    isNewAddress: boolean;\n    isPaymentDataRequired: boolean;\n    loadInstruments(): Promise<CheckoutSelectors>;\n}\n\nfunction getHostedPaymentMethodDerivedProps(\n    props: HostedPaymentComponentProps,\n): HostedPaymentComponentDerivedProps {\n    const filterAccountInstruments = memoizeOne((instruments: PaymentInstrument[] = []) =>\n        instruments.filter(isAccountInstrument),\n    );\n    const filterTrustedInstruments = memoizeOne((instruments: AccountInstrument[] = []) =>\n        instruments.filter(({ trustedShippingAddress }) => trustedShippingAddress),\n    );\n    const { checkoutService, checkoutState, isUsingMultiShipping = false, method } = props;\n\n    const {\n        data: {\n            getCart,\n            getConfig,\n            getCustomer,\n            getInstruments,\n            isPaymentDataRequired,\n            isPaymentDataSubmitted,\n        },\n        statuses: { isLoadingInstruments },\n    } = checkoutState;\n\n    const cart = getCart();\n    const config = getConfig();\n    const customer = getCustomer();\n\n    if (!config || !cart || !customer) {\n        throw new Error('Unable to get checkout');\n    }\n\n    const currentMethodInstruments = filterAccountInstruments(getInstruments(method));\n    const trustedInstruments = filterTrustedInstruments(currentMethodInstruments);\n\n    return {\n        instruments: trustedInstruments,\n        isNewAddress: trustedInstruments.length === 0 && currentMethodInstruments.length > 0,\n        isInstrumentFeatureAvailable:\n            !isPaymentDataSubmitted(method.id, method.gateway) &&\n            isInstrumentFeatureAvailable({\n                config,\n                customer,\n                isUsingMultiShipping,\n                paymentMethod: method,\n            }),\n        isLoadingInstruments: isLoadingInstruments(),\n        isPaymentDataRequired: isPaymentDataRequired(),\n        loadInstruments: checkoutService.loadInstruments,\n    };\n}\n\nconst HostedPaymentMethodComponent: React.FC<HostedPaymentComponentProps> = (props) => {\n    const {\n        description,\n        isInitializing = false,\n        initializePayment,\n        method,\n        onUnhandledError = noop,\n        deinitializePayment,\n    } = props;\n\n    const [isAddingNewInstrument, setIsAddingNewInstrument] = useState(false);\n    const [selectedInstrument, setSelectedInstrument] = useState<AccountInstrument | undefined>();\n\n    const derivedProps = getHostedPaymentMethodDerivedProps(props);\n    const {\n        isLoadingInstruments,\n        instruments,\n        isNewAddress,\n        isInstrumentFeatureAvailable: isInstrumentFeatureAvailableProp,\n        loadInstruments,\n    } = derivedProps;\n\n    const getDefaultInstrument = useCallback((): AccountInstrument | undefined => {\n        if (isAddingNewInstrument || !instruments.length) {\n            return;\n        }\n\n        return find(instruments, { defaultInstrument: true }) || instruments[0];\n    }, [isAddingNewInstrument, instruments]);\n\n    const handleUseNewInstrument = useCallback(() => {\n        setIsAddingNewInstrument(true);\n        setSelectedInstrument(undefined);\n    }, []);\n\n    const handleSelectInstrument = useCallback(\n        (id: string) => {\n            setIsAddingNewInstrument(false);\n            setSelectedInstrument(find(instruments, { bigpayToken: id }));\n        },\n        [instruments],\n    );\n\n    useEffect(() => {\n        const initializePaymentAsync = async () => {\n            try {\n                await initializePayment({\n                    gatewayId: method.gateway,\n                    methodId: method.id,\n                });\n\n                if (isInstrumentFeatureAvailableProp) {\n                    await loadInstruments();\n                }\n            } catch (error) {\n                onUnhandledError(error);\n            }\n        };\n\n        void initializePaymentAsync();\n\n        return () => {\n            const deinitializePaymentAsync = async () => {\n                try {\n                    await deinitializePayment({\n                        gatewayId: method.gateway,\n                        methodId: method.id,\n                    });\n                } catch (error) {\n                    onUnhandledError(error);\n                }\n            };\n\n            void deinitializePaymentAsync();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    const currentSelectedInstrument = selectedInstrument || getDefaultInstrument();\n    const isLoading = isInitializing || isLoadingInstruments;\n    const shouldShowInstrumentFieldset =\n        isInstrumentFeatureAvailableProp && (instruments.length > 0 || isNewAddress);\n\n    if (!description && !isInstrumentFeatureAvailableProp) {\n        return null;\n    }\n\n    return (\n        <LoadingOverlay hideContentWhenLoading isLoading={isLoading}>\n            <div className=\"paymentMethod paymentMethod--hosted\">\n                {description}\n\n                {shouldShowInstrumentFieldset && (\n                    <AccountInstrumentFieldset\n                        instruments={instruments}\n                        onSelectInstrument={handleSelectInstrument}\n                        onUseNewInstrument={handleUseNewInstrument}\n                        selectedInstrument={currentSelectedInstrument}\n                    />\n                )}\n\n                {isInstrumentFeatureAvailableProp && (\n                    <StoreInstrumentFieldset\n                        instrumentId={\n                            currentSelectedInstrument && currentSelectedInstrument.bigpayToken\n                        }\n                        instruments={instruments}\n                        isAccountInstrument={true}\n                    />\n                )}\n            </div>\n        </LoadingOverlay>\n    );\n};\n\nexport default HostedPaymentMethodComponent;\n","import { type PaymentInitializeOptions } from '@bigcommerce/checkout-sdk';\nimport { createCreditCardPaymentStrategy } from '@bigcommerce/checkout-sdk/integrations/credit-card';\nimport React, { type FunctionComponent, useCallback } from 'react';\n\nimport { HostedPaymentComponent } from '@bigcommerce/checkout/hosted-payment-integration';\nimport {\n    type PaymentMethodProps,\n    type PaymentMethodResolveId,\n    toResolvableComponent,\n} from '@bigcommerce/checkout/payment-integration-api';\n\nconst BarclaycardPaymentMethod: FunctionComponent<PaymentMethodProps> = ({\n    checkoutService,\n    checkoutState,\n    method,\n    paymentForm,\n    ...rest\n}) => {\n    const initializeBarclaycardPayment = useCallback(\n        (options: PaymentInitializeOptions) => {\n            return checkoutService.initializePayment({\n                ...options,\n                integrations: [createCreditCardPaymentStrategy],\n            });\n        },\n        [checkoutService],\n    );\n\n    return (\n        <HostedPaymentComponent\n            {...rest}\n            checkoutService={checkoutService}\n            checkoutState={checkoutState}\n            deinitializePayment={checkoutService.deinitializePayment}\n            initializePayment={initializeBarclaycardPayment}\n            method={method}\n            paymentForm={paymentForm}\n        />\n    );\n};\n\nexport default toResolvableComponent<PaymentMethodProps, PaymentMethodResolveId>(\n    BarclaycardPaymentMethod,\n    [{ gateway: 'barclaycard' }],\n);\n","import StandardError from './standard-error';\n\nexport enum NotInitializedErrorType {\n    CheckoutButtonNotInitialized,\n    CustomerNotInitialized,\n    PaymentNotInitialized,\n    ShippingNotInitialized,\n    SpamProtectionNotInitialized,\n}\n\n/**\n * Throw this error if a method requires a certain initialization call to be\n * made first. Some objects can be constructed but they cannot be used until a\n * separate initialization call is made.\n */\nexport default class NotInitializedError extends StandardError {\n    constructor(public subtype: NotInitializedErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'NotInitializedError';\n        this.type = 'not_initialized';\n    }\n}\n\nfunction getErrorMessage(type: NotInitializedErrorType): string {\n    switch (type) {\n        case NotInitializedErrorType.CustomerNotInitialized:\n            return 'Unable to proceed because the customer step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.PaymentNotInitialized:\n            return 'Unable to proceed because the payment step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.ShippingNotInitialized:\n            return 'Unable to proceed because the shipping step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.SpamProtectionNotInitialized:\n            return 'Unable to proceed because the checkout spam protection has not been initialized.';\n\n        default:\n            return 'Unable to proceed because the required component has not been initialized.';\n    }\n}\n","import CustomError from './custom-error';\nimport setPrototypeOf from './set-prototype-of';\n\n/**\n * This error type should not be constructed directly. It is a base class for\n * all custom errors thrown in this library.\n */\nexport default abstract class StandardError extends Error implements CustomError {\n    name = 'StandardError';\n    type = 'standard';\n\n    constructor(message?: string) {\n        super(message || 'An unexpected error has occurred.');\n\n        setPrototypeOf(this, new.target.prototype);\n\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, new.target);\n        } else {\n            this.stack = new Error(this.message).stack;\n        }\n    }\n}\n","export default function setPrototypeOf(object: any, prototype: object) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(object, prototype);\n    } else {\n        object.__proto__ = prototype;\n    }\n\n    return object;\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a method is unable to proceed because the\n * caller has not provided all the arguments according to their requirements,\n * i.e.: if an argument is missing or it is not the expected data type.\n */\nexport default class InvalidArgumentError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Invalid arguments have been provided.');\n\n        this.name = 'InvalidArgumentError';\n        this.type = 'invalid_argument';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * Throw this error if we are trying to make an order finalization request for a\n * payment method that does not require such procedure.\n */\nexport default class OrderFinalizationNotRequiredError extends StandardError {\n    constructor() {\n        super('The current order does not need to be finalized at this stage.');\n\n        this.name = 'OrderFinalizationNotRequiredError';\n        this.type = 'order_finalization_not_required';\n    }\n}\n","import InvalidArgumentError from './invalid-argument-error';\n\n/**\n * This error should be thrown when we are unable to submit a payment because\n * the caller has not provided all the required fields, i.e.: if an argument is\n * missing or it is not the expected data type.\n */\nexport default class PaymentArgumentInvalidError extends InvalidArgumentError {\n    constructor(invalidFields?: string[]) {\n        let message = 'Unable to submit payment for the order because the payload is invalid.';\n\n        if (invalidFields) {\n            message = `${message} Make sure the following fields are provided correctly: ${invalidFields.join(\n                ', ',\n            )}.`;\n        }\n\n        super(message);\n\n        this.name = 'PaymentArgumentInvalidError';\n    }\n}\n","import { isNil, values } from 'lodash';\n\nimport {\n    HostedForm,\n    InvalidArgumentError,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    PaymentArgumentInvalidError,\n    PaymentInitializeOptions,\n    PaymentIntegrationService,\n    PaymentRequestOptions,\n    PaymentStrategy,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { WithCreditCardPaymentInitializeOptions } from './credit-card-payment-initialize-options';\n\nexport default class CreditCardPaymentStrategy implements PaymentStrategy {\n    protected _hostedForm?: HostedForm;\n    protected _shouldRenderHostedForm?: boolean;\n\n    constructor(protected _paymentIntegrationService: PaymentIntegrationService) {}\n\n    execute(payload: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        return this._isHostedPaymentFormEnabled(\n            payload.payment?.methodId,\n            payload.payment?.gatewayId,\n        ) && this._shouldRenderHostedForm\n            ? this._executeWithHostedForm(payload, options)\n            : this._executeWithoutHostedForm(payload, options);\n    }\n\n    initialize(\n        options?: PaymentInitializeOptions & WithCreditCardPaymentInitializeOptions,\n    ): Promise<void> {\n        if (\n            !this._isHostedPaymentFormEnabled(options?.methodId, options?.gatewayId) ||\n            !this._isHostedFieldAvailable(options)\n        ) {\n            this._shouldRenderHostedForm = false;\n\n            return Promise.resolve();\n        }\n\n        const formOptions = options && options.creditCard && options.creditCard.form;\n        const state = this._paymentIntegrationService.getState();\n        const { paymentSettings: { bigpayBaseUrl: host = '' } = {} } =\n            state.getStoreConfigOrThrow();\n\n        if (!formOptions) {\n            throw new InvalidArgumentError();\n        }\n\n        const form = this._paymentIntegrationService.createHostedForm(host, formOptions);\n\n        return form.attach().then(() => {\n            this._shouldRenderHostedForm = true;\n            this._hostedForm = form;\n\n            return Promise.resolve();\n        });\n    }\n\n    deinitialize(): Promise<void> {\n        if (this._hostedForm) {\n            this._hostedForm.detach();\n        }\n\n        return Promise.resolve();\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    protected async _executeWithoutHostedForm(\n        payload: OrderRequestBody,\n        options?: PaymentRequestOptions,\n    ): Promise<void> {\n        const { payment, ...order } = payload;\n        const paymentData = payment && payment.paymentData;\n\n        if (!payment || !paymentData) {\n            throw new PaymentArgumentInvalidError(['payment.paymentData']);\n        }\n\n        await this._paymentIntegrationService.submitOrder(order, options);\n\n        await this._paymentIntegrationService.submitPayment({ ...payment, paymentData });\n    }\n\n    protected async _executeWithHostedForm(\n        payload: OrderRequestBody,\n        options?: PaymentRequestOptions,\n    ): Promise<void> {\n        const { payment, ...order } = payload;\n        const form = this._hostedForm;\n\n        if (!form) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        if (!payment || !payment.methodId) {\n            throw new PaymentArgumentInvalidError(['payment.methodId']);\n        }\n\n        await this._paymentIntegrationService.submitOrder(order, options);\n\n        await form.validate().then(() => form.submit(payment));\n    }\n\n    protected _isHostedPaymentFormEnabled(methodId?: string, gatewayId?: string): boolean {\n        if (!methodId) {\n            return false;\n        }\n\n        const state = this._paymentIntegrationService.getState();\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId, gatewayId);\n\n        return paymentMethod.config.isHostedFormEnabled === true;\n    }\n\n    private _isHostedFieldAvailable(\n        options?: PaymentInitializeOptions & WithCreditCardPaymentInitializeOptions,\n    ): boolean {\n        return !values(options && options.creditCard && options.creditCard.form.fields).every(\n            isNil,\n        );\n    }\n}\n","import {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport CreditCardPaymentStrategy from './credit-card-payment-strategy';\n\nconst createCreditCardPaymentStrategy: PaymentStrategyFactory<CreditCardPaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new CreditCardPaymentStrategy(paymentIntegrationService);\n};\n\nexport default toResolvableModule(createCreditCardPaymentStrategy, [{ default: true }]);\n","import ResolvableModule from './resolvable-module';\n\nexport default function toResolvableModule<TModule, TIdentifier>(\n    module: TModule,\n    resolveIds: TIdentifier[],\n): ResolvableModule<TModule, TIdentifier> {\n    return Object.assign(module, { resolveIds });\n}\n","import { type Customer, type PaymentMethod, type StoreConfig } from '@bigcommerce/checkout-sdk';\n\nexport interface IsInstrumentFeatureAvailableState {\n    config: StoreConfig;\n    customer: Customer;\n    isUsingMultiShipping: boolean;\n    paymentMethod: PaymentMethod;\n}\n\nexport default function isInstrumentFeatureAvailable({\n    config,\n    customer,\n    isUsingMultiShipping,\n    paymentMethod,\n}: IsInstrumentFeatureAvailableState): boolean {\n    if (\n        !config.checkoutSettings.isCardVaultingEnabled ||\n        !paymentMethod.config.isVaultingEnabled ||\n        customer.isGuest ||\n        isUsingMultiShipping\n    ) {\n        return false;\n    }\n\n    return true;\n}\n"],"names":["props","description","isInitializing","initializePayment","method","onUnhandledError","noop","deinitializePayment","isAddingNewInstrument","setIsAddingNewInstrument","useState","selectedInstrument","setSelectedInstrument","derivedProps","filterAccountInstruments","instruments","filter","filterTrustedInstruments","trustedShippingAddress","checkoutService","checkoutState","isUsingMultiShipping","data","getCart","getConfig","getCustomer","getInstruments","isPaymentDataRequired","isPaymentDataSubmitted","statuses","isLoadingInstruments","cart","config","customer","Error","currentMethodInstruments","trustedInstruments","isNewAddress","length","isInstrumentFeatureAvailable","id","gateway","paymentMethod","loadInstruments","getHostedPaymentMethodDerivedProps","isInstrumentFeatureAvailableProp","getDefaultInstrument","useCallback","find","defaultInstrument","handleUseNewInstrument","undefined","handleSelectInstrument","bigpayToken","useEffect","gatewayId","methodId","error","currentSelectedInstrument","isLoading","shouldShowInstrumentFieldset","hideContentWhenLoading","className","A","onSelectInstrument","onUseNewInstrument","instrumentId","isAccountInstrument","paymentForm","rest","initializeBarclaycardPayment","options","integrations","HostedPaymentComponent","NotInitializedErrorType","StandardError","constructor","message","prototype","super","name","type","Object","setPrototypeOf","this","__proto__","captureStackTrace","stack","InvalidArgumentError","OrderFinalizationNotRequiredError","PaymentArgumentInvalidError","invalidFields","join","CheckoutButtonNotInitialized","CustomerNotInitialized","PaymentNotInitialized","ShippingNotInitialized","SpamProtectionNotInitialized","NotInitializedError","subtype","CreditCardPaymentStrategy","_paymentIntegrationService","execute","payload","_isHostedPaymentFormEnabled","payment","_shouldRenderHostedForm","_executeWithHostedForm","_executeWithoutHostedForm","initialize","_isHostedFieldAvailable","Promise","resolve","formOptions","creditCard","form","state","getState","paymentSettings","bigpayBaseUrl","host","getStoreConfigOrThrow","createHostedForm","attach","then","_hostedForm","deinitialize","detach","finalize","reject","order","paymentData","submitOrder","submitPayment","validate","submit","getPaymentMethodOrThrow","isHostedFormEnabled","values","fields","every","isNil","module","paymentIntegrationService","resolveIds","default","assign","checkoutSettings","isCardVaultingEnabled","isVaultingEnabled","isGuest"],"sourceRoot":""}